# Travel Itinerary Planner - Design Summary

## Overview
Travel Itinerary Planner is a web application that helps users organize multi-day trips by generating smart, customizable daily schedules. The app leverages AI to suggest activities and optimal grouping, allowing users to manually adjust and share their itineraries.

---

## Architecture
- **Backend:** Python (Flask)
- **Database:** SQLite (via SQLAlchemy ORM)
- **Frontend:** HTML, Bootstrap 5, custom CSS
- **AI Integration:** Google Gemini API (via `google-generativeai`)

---

## Main Components

### 1. Trip Management
- Users create trips by entering destination, start date, number of days, and notes/interests.
- Trips are stored in the `Trip` table.

### 2. Activity Selection
- Activities are loaded from a static JSON file or generated by Gemini AI based on user notes.
- Users select activities for their trip.
- Selected activities are stored in the `Activity` table and marked with a `selected` flag.

### 3. AI-Generated Scheduling
- Selected activities are sent to Gemini AI to generate a day-by-day itinerary.
- The AI prompt includes trip details, activities, and constraints (group by location, max hours/day, mix categories).
- The schedule is parsed and days are assigned to activities in the database.

### 4. Manual Editing
- Users can manually reassign activities to different days via the edit itinerary page.
- Changes are saved to the database and reflected in the itinerary.

### 5. Sharing
- Users can view and share a read-only itinerary link.
- The share page displays only selected activities and their assigned days.

---

## Workflow
1. **Create Trip:** User enters trip details.
2. **Select Activities:** User browses and selects activities (AI-generated or static).
3. **Generate Schedule:** AI creates a daily plan; user reviews.
4. **Edit Itinerary:** User manually adjusts activity days as needed.
5. **Share Itinerary:** User shares a read-only link with travel companions.

---

## Data Model
- **Trip:** id, destination, start_date, num_days, notes
- **Activity:** id, trip_id, name, category, duration, location, day, selected

---

## AI Prompts
- Prompts are used to generate activities and schedules based on user interests and trip constraints.
- Prompts are documented in the code and can be extracted for reference.

---

## Error Handling & User Experience
- Basic error handling for AI failures and empty results.
- Clean, modern UI with Bootstrap and custom styles.
- No login/account required for sharing itineraries.

---

## Extensibility
- Easily extendable to support more activity sources, advanced editing (drag-and-drop), or user authentication.

---

## Acceptance Criteria Coverage
- All workflow steps are implemented.
- AI assistant is integrated.
- Manual editing and sharing are supported.
- Further documentation and tests/screenshots recommended for full acceptance.

---

## Author & Version
- Generated by GitHub Copilot
- Date: October 16, 2025




Design Constraints and Technology Choices

While developing the AI-powered Travel Itinerary Planner, it was essential to ensure that the AI-generated suggestions and code adhered to a well-defined technical architecture and remained compatible with the chosen technology stack. Therefore, explicit design constraints and technology guidelines were embedded in the AI prompts and project planning phase.

1. Architectural Design Constraints

To maintain modularity, scalability, and clarity, the following architectural constraints were given to the AI during code generation and system design:

Pattern Used:
Adopt a Model–View–Controller (MVC) architecture to separate concerns:

Model: SQLAlchemy ORM models for Trip and Activity

View: HTML templates rendered using Flask’s Jinja2

Controller: Flask routes handling logic, API calls, and AI integration

Core Constraints:

Keep AI logic isolated from business logic for maintainability.

All AI responses must be validated before being saved in the database.

Ensure data flow consistency between AI, database, and frontend.

Avoid complex dependencies that could slow deployment or increase debugging time.

Design Emphasis:

Simple backend routes with reusable functions.

Readable, modular code with clear separation of roles.

Lightweight design that can run locally or on small cloud servers (e.g., Render, Railway).

2. Technology Stack Choices

To align with project goals and keep the system both efficient and deployable, the following technology choices were fixed and communicated to the AI while generating or refining code:

Component	Technology	Reason
Backend Framework	Flask	Lightweight, easy to integrate with APIs, ideal for small-to-medium AI-based web apps.
Frontend	HTML5, CSS3, Bootstrap	Simple responsive UI for easy viewing on mobile and desktop.
Database	SQLite (development), PostgreSQL (optional for deployment)	Lightweight for local testing, scalable for production.
ORM	SQLAlchemy	Simplifies database interaction and model management.
AI Model	Google Gemini 2.5 Flash	Fast, structured output, supports text-based JSON responses.
Templating	Jinja2	Allows dynamic rendering of itinerary and user data.
Version Control	Git + GitHub	For collaborative version management.
3. AI Design Constraints

To ensure reliability and consistency in AI outputs, the following explicit constraints were added in prompts and backend logic:

Always return data in strict JSON format.

Ensure valid keys exist in all activities (name, category, duration, location).

Group activities logically by location and duration ≤ 8 hours/day.

Avoid generating explanations or markdown formatting unless explicitly requested.

Generate deterministic, structured responses suitable for parsing with json.loads().

Example snippet from the prompt:

Return JSON only:
[{"name": "...", "category": "...", "duration": 2, "location": "..."}]

4. Implementation-Level Constraints

To maintain robustness and code quality:

Validation checks were placed before inserting data into the database.

Regular expressions (regex) were used to safely extract JSON from AI responses.

Fallback mechanisms were added (static JSON data) if AI output failed validation.

Maximum runtime for AI requests was limited to ensure responsiveness.

Error handling and logging were implemented to detect malformed responses.

5. Why These Choices Were Important

These constraints and technology decisions:

Kept the app lightweight, maintainable, and easy to debug.

Allowed quick iteration and testing of AI prompts.

Prevented the AI from generating incompatible or over-engineered solutions.

Ensured that the final design was both technically feasible and aligned with software engineering best practices.